# scripts to take the place of biahub-register

import dexpv2
import numpy as np
from numpy.typing import ArrayLike
import yaml
import dask.array as da

from iohub import open_ome_zarr
import cupy as cp
from pathlib import Path
from iohub.ngff import TransformationMeta

try:
    import cupy as xp
    from cupyx.scipy import ndimage as cundi

except (ModuleNotFoundError, ImportError):
    import numpy as xp
    from scipy import ndimage as cundi

# TODO: change imports so that it works on GPU or CPU


def register(
    input_path: str,
    target_path: str,
    transform_path: str,
    output_path: str,
    position: str,
):
    """
    Apply an affine transform to the input such that it is registered to the target, then save the result as a new OME-Zarr

    Processes a single position, becuase transform is calculated for a single position
    """
    # TODO: handle a list of positions and transforms

    affine_matrix = read_transform_biahub(transform_path)

    input_ds = open_ome_zarr(input_path)
    target_ds = open_ome_zarr(target_path)

    output_store = open_ome_zarr(
        output_path, layout="hcs", mode="a", channel_names=input_ds.channel_names
    )

    # Assumes a 2D array (for now)
    target_shape = target_ds[position].data.shape[-3:]
    input_array = da.from_array(input_ds[position].data[0, 0, :, :, :])

    transformed = apply_affine_ome_zarr(input_array, affine_matrix, target_shape)
    transformed = np.expand_dims(transformed.get(), axis=(0, 1))

    out_pos = output_store.create_position(*Path(position).parts)
    out_pos.create_image(
        name="0",
        data=transformed,
        chunks=target_ds[position].data.chunks,
        transform=[TransformationMeta(type="scale", scale=target_ds[position].scale)],
    )

    return transformed


def apply_affine_ome_zarr(array, transform, target_shape) -> np.array:
    """
    Apply an affine transform to an array
    """
    xp_array = xp.asarray(array)
    xp_transform = xp.asarray(transform)

    transformed = cundi.affine_transform(
        xp_array, xp_transform, order=0, output_shape=target_shape
    )

    return transformed


def read_transform_biahub(
    transform_path: str,
) -> np.array:
    """
    read an afine matrix tranform generated by `biahub-estimate-registration`
    and convert it into a form compatible with dexpv2 apply affine transform
    """

    with open(transform_path, "r") as file:
        raw_settings = yaml.safe_load(file)

    return np.asarray(raw_settings["affine_transform_zyx"])

